
"""
This file was automatically generated by 'graphql-codegen'.
Please do not edit this file directly.
To regenerate this file, run `npm run generate:gql`
"""

input AddMemberInput {
  """The ID of the organization to add the user to"""
  organizationId: ID!

  """The role of the user in the organization, defaults to Role.MEMBER"""
  role: Role

  """The ID of the user to add to the organization"""
  userId: ID!
}

type AddMemberResponse {
  member: Member!
}

type Booking {
  cabin: Cabin!
  email: String!
  endDate: DateTime!
  firstName: String!
  id: ID!
  lastName: String!
  phoneNumber: String!
  startDate: DateTime!
  status: Status!
}

type BookingContact {
  email: String!
  id: ID!
  name: String!
  phoneNumber: String!
}

type BookingContactResponse {
  bookingContact: BookingContact!
}

type BookingSemester {
  bookingsEnabled: Boolean!
  endAt: DateTime!
  id: ID!
  semester: Semester!
  startAt: DateTime!
}

type BookingSemestersResponse {
  fall: BookingSemester
  spring: BookingSemester
}

type Cabin {
  capacity: Int!
  externalPrice: Int!
  id: ID!
  internalPrice: Int!
  name: String!
}

type CabinsResponse {
  cabins: [Cabin!]!
}

input CreateEventCategoryInput {
  name: String!
}

type CreateEventCategoryResponse {
  category: EventCategory!
}

input CreateEventInput {
  event: EventData!
}

type CreateEventResponse {
  event: Event!
}

input CreateEventSlot {
  capacity: Int!
  gradeYears: [Int!]
}

input CreateListingInput {
  """An optional URL to the application form for the listing."""
  applicationUrl: String

  """
  At what time the listing will close, will show as a deadline to users, and the listing will be hidden afterwards
  """
  closesAt: DateTime!

  """The description of the listing, can be markdown."""
  description: String

  """The name of the listing, will be visible to users."""
  name: String!

  """The ID of the organization that the listing belongs to."""
  organizationId: ID!
}

type CreateListingResponse {
  listing: Listing!
}

input CreateMerchantInput {
  """Client ID for the merchant, retrieved from the payment provider."""
  clientId: String!

  """Client secret for the merchant, retrieved from the payment provider."""
  clientSecret: String!

  """The name of the merchant to create."""
  name: String!

  """
  Merchant serial number for the merchant, retrieved from the payment provider.
  """
  serialNumber: String!

  """
  Subscription key for the merchant, retrieved from the payment provider.
  """
  subscriptionKey: String!
}

type CreateMerchantResponse {
  """The merchant that was created."""
  merchant: Merchant!
}

input CreateOrderInput {
  """The ID of the product to create an order for."""
  productId: ID!
}

type CreateOrderResponse {
  order: Order!
}

input CreateOrganizationInput {
  """The description of the organization, cannot exceed 10 000 characters"""
  description: String

  """
  Features to enable for the organization. Defaults to an empty list.
  Requires that the current user is a super user, otherwise, this field is ignored.
  """
  featurePermissions: [FeaturePermission!]

  """
  The name of the organization, must be unique and between 1 and 100 characters
  """
  name: String!
}

type CreateOrganizationResponse {
  organization: Organization!
}

input CreateSlotInput {
  capacity: Int!
  gradeYears: [Int!]
}

scalar DateTime

input DeleteEventCategoryInput {
  id: ID!
}

type DeleteEventCategoryResponse {
  category: EventCategory!
}

input DeleteListingInput {
  id: ID!
}

type DeleteListingResponse {
  listing: Listing!
}

input DeleteSlotInput {
  id: ID!
}

type Event {
  """
  canSignUp is true if the current user can sign up for the event, false otherwise.
  If the user is not logged in, this will be always be false.
  """
  canSignUp: Boolean!

  """categories describes the categories that the event belongs to."""
  categories: [EventCategory!]

  """The contact email for the event organizer."""
  contactEmail: String!

  """
  The description of the event. We support markdown on the client, so this can be markdown.
  """
  description: String!

  """The end time of the event."""
  endAt: DateTime!
  id: ID!

  """The location of the event"""
  location: String!

  """The name of the event."""
  name: String!

  """The organization that is hosting the event."""
  organization: Organization

  """
  signUpAvailability describes the availability of sign ups for the event for the current user.
  """
  signUpAvailability: SignUpAvailability!
  signUpDetails: EventSignUpDetails
  signUps: SignUps
  signUpsEnabled: Boolean!

  """
  If true, signing up for the event requires that the user submits additional information.
  """
  signUpsRequireUserProvidedInformation: Boolean!

  """
  If true, sign ups can be retracted for the event. Otherwise, sign ups are final.
  """
  signUpsRetractable: Boolean!

  """The start time of the event."""
  startAt: DateTime!

  """The ticket information for the event, if the event is a TICKETS event."""
  ticketInformation: EventTicketInformation
  type: EventType!
  user: EventUser
}

type EventCategoriesResponse {
  categories: [EventCategory!]!
}

type EventCategory {
  id: ID!
  name: String!
}

input EventCategoryInput {
  id: ID!
}

input EventData {
  """categories is a list of cateogry IDs to which the event belongs"""
  categories: [EventCategoryInput!]

  """
  The description of the event, defaults to "". We support markdown on the client, so this can be markdown.
  This will be displayed to users.
  """
  description: String

  """
  The end time of the event. If this is not provided, the event will be assumed to be two hours long.
  This will be displayed to users.
  """
  endAt: DateTime

  """The name of the event, this will be displayed to users"""
  name: String!

  """
  The ID of the organization that is hosting the event. Events must be hosted by an organization, and the user
  creating the event must be a member of the organization.
  """
  organizationId: ID!

  """If the event is a sign up event, this will be the sign up details."""
  signUpDetails: SignUpData

  """
  If sign ups are currently enabled for the event. If this is false, users cannot sign up for the event. Defaults to
  false
  """
  signUpsEnabled: Boolean

  """
  If true, signing up requires that the user submits additional information. Defaults to false
  """
  signUpsRequireUserProvidedInformation: Boolean

  """
  If true, users can retract their sign up for the event. Defaults to false
  """
  signUpsRetractable: Boolean

  """The start time of the event. Events must have a start time."""
  startAt: DateTime!

  """
  The event type
  - BASIC has no sign ups, and no tickets
  - SIGN_UPS has sign ups, but no tickets (free event)
  - TICKETS has tickets and sign ups (paid event)
  """
  type: EventType!
}

input EventInput {
  id: ID!
}

type EventResponse {
  event: Event!
}

type EventSignUpDetails {
  capacity: Int!
  signUpsEndAt: DateTime!
  signUpsStartAt: DateTime!
}

input EventTicketData {
  """
  MerchantID is the ID for the merchant, this will be the recipient of the payments.
  """
  merchantId: ID!

  """Price in øre, i.e. 100 = 1 NOK"""
  price: Int!
}

type EventTicketInformation {
  product: Product
}

enum EventTicketStatus {
  BOUGHT
  NOT_BOUGHT
}

enum EventType {
  """Basic event has no sign ups, and no tickets"""
  BASIC

  """Sign up event has sign ups, but no tickets"""
  SIGN_UPS

  """Ticketed event has tickets and sign ups"""
  TICKETS
}

type EventUser {
  """The ID of the user"""
  id: ID!
  signUp: SignUp
  ticket: Order

  """
  The ticket status for the user on the event, null if it's not a ticket event
  """
  ticketStatus: EventTicketStatus
}

input EventsInput {
  """
  If true, only return events that are currently happening, or will happen in the future
  i.e. events where endAt is in the future.
  """
  futureEventsOnly: Boolean
}

type EventsResponse {
  """All events, if futureEventsOnly is false, otherwise only future events"""
  events: [Event!]!

  """The events that start next week, by week number"""
  nextWeek: [Event!]!

  """The events that start this week, by week number"""
  thisWeek: [Event!]!

  """The total number of events returned by this query (for now)"""
  total: Int!

  """The events that start in two weeks or later, by week number"""
  twoWeeksOrLater: [Event!]!
}

enum FeaturePermission {
  ARCHIVE_VIEW_DOCUMENTS
  ARCHIVE_WRITE_DOCUMENTS
  CABIN_ADMIN
  EVENT_WRITE_SIGN_UPS
}

input HasFeaturePermissionInput {
  featurePermission: FeaturePermission!
}

type HasFeaturePermissionResponse {
  hasFeaturePermission: Boolean!
  id: FeaturePermission!
}

input HasRoleInput {
  organizationId: ID!
  role: Role!
}

type HasRoleResponse {
  hasRole: Boolean!
}

input InitiatePaymentAttemptInput {
  """The ID of the order to initiate a payment attempt for."""
  orderId: ID!

  """
  The return URL to redirect the user to after the payment attempt has been completed.
  """
  returnUrl: String!
}

type InitiatePaymentAttemptResponse {
  """The URL to redirect the user to in order to complete the payment."""
  redirectUrl: String!
}

type Listing {
  """
  An optional URL to the application form for the listing, defaults to ""
  """
  applicationUrl: String!

  """
  When the listing closes, i.e. deadline, or when the listing is hidden from view.
  """
  closesAt: DateTime!

  """The description of the listing, can be markdown."""
  description: String!
  id: ID!

  """The name/title of the listing, will be visible to users."""
  name: String!

  """The organization that the listing belongs to."""
  organization: Organization!
}

input ListingInput {
  id: ID!
}

type ListingResponse {
  listing: Listing!
}

type ListingsResponse {
  listings: [Listing!]!
}

type Member {
  id: ID!

  """The organization the member is a member of"""
  organization: Organization!

  """The role of the member in the organization"""
  role: Role!

  """The user that is a member of the organization"""
  user: PublicUser!
}

type Merchant {
  id: ID!
  name: String!
}

type Mutation {
  """Add a member to the organization"""
  addMember(data: AddMemberInput!): AddMemberResponse!

  """
  Create an event, requires that the user is logged in, and is a member of the organization that is hosting the event
  """
  createEvent(data: CreateEventInput!): CreateEventResponse!

  """Create a new event category, requires super user status"""
  createEventCategory(data: CreateEventCategoryInput!): CreateEventCategoryResponse!
  createListing(data: CreateListingInput!): CreateListingResponse!

  """
  Create a new Vipps merchant, and return the created merchant.
  Requires super user status.
  """
  createMerchant(data: CreateMerchantInput!): CreateMerchantResponse!

  """Creates an order for the given product."""
  createOrder(data: CreateOrderInput!): CreateOrderResponse!

  """
  Create a new organization, and add the current user as an admin of the organization.
  """
  createOrganization(data: CreateOrganizationInput!): CreateOrganizationResponse!

  """Delete an event category, requires super user status"""
  deleteEventCategory(data: DeleteEventCategoryInput!): DeleteEventCategoryResponse!
  deleteListing(data: DeleteListingInput!): DeleteListingResponse!

  """Initiates a payment attempt for the given order."""
  initiatePaymentAttempt(data: InitiatePaymentAttemptInput!): InitiatePaymentAttemptResponse!
  newBooking(data: NewBookingInput!): NewBookingResponse!

  """Remove a member from the organization by the ID of the membership."""
  removeMember(data: RemoveMemberInput!): RemoveMemberResponse!

  """
  Retract an active sign up for an event, requires that the user is logged in
  """
  retractSignUp(data: RetractSignUpInput!): RetractSignUpResponse!

  """Sign up for an event, requires that the user is logged in"""
  signUp(data: SignUpInput!): SignUpResponse!

  """
  Update the user with the given ID with super user privileges, requires that
  the caller is an authenticated super user. Otherwise, use updateUser.
  """
  superUpdateUser(data: SuperUpdateUserInput!, id: ID!): SuperUpdateUserResponse!

  """
  Updates the booking contact, requires that the user is in an organization with the CABIN_ADMIN permission.
  """
  updateBookingContact(data: UpdateBookingContactInput!): UpdateBookingContactResponse!

  """
  Updates the booking semester for the given semester, requires that the user is in an organization with
  the CABIN_ADMIN permission.
  """
  updateBookingSemester(data: UpdateBookingSemesterInput!): UpdateBookingSemesterResponse!
  updateBookingStatus(data: UpdateBookingStatusInput!): UpdateBookingResponse!

  """"""
  updateEvent(data: UpdateEventInput!, id: ID!): UpdateEventResponse!

  """Update an event category, requires super user status"""
  updateEventCategory(data: UpdateEventCategoryInput!): UpdateEventCategoryResponse!
  updateListing(data: UpdateListingInput!, id: ID!): UpdateListingResponse!

  """
  Update an organization with the given name and description.
  Passing null or omitting a value will leave the value unchanged.
  """
  updateOrganization(data: UpdateOrganizationInput!): UpdateOrganizationResponse!
  updateUser(data: UpdateUserInput!): UpdateUserResponse!
}

input NewBookingInput {
  cabinId: ID!
  email: String!
  endDate: DateTime!
  firstName: String!
  lastName: String!
  phoneNumber: String!
  startDate: DateTime!
}

type NewBookingResponse {
  booking: Booking!
}

type Order {
  """Number of attempts to pay for the order."""
  attempt: Int!
  capturedPaymentAttempt: PaymentAttempt

  """The date and time the order was created."""
  createdAt: DateTime!
  id: ID!
  isFinalState: Boolean!
  paymentAttempt(reference: String): PaymentAttempt
  paymentAttempts: PaymentAttemptsResponse!

  """
  The current payment status of the order. This is updated asynchronously, so if the payment status is PENDING or CREATED,
  it is recommended to poll the order to get the current status.
  """
  paymentStatus: OrderPaymentStatus!

  """The product that the order is for."""
  product: Product!
  purchasedAt: DateTime

  """"""
  totalPrice: Price!
  user: PrivateUser
}

input OrderInput {
  id: ID!
}

enum OrderPaymentStatus {
  """The order has been cancelled. This is a final state."""
  CANCELLED

  """
  The payment attempt has been authorized, but and the payment has been captured. This is a final state.
  """
  CAPTURED

  """The order has been created, and a payment attempt has been made."""
  CREATED

  """The order has been created, but no payment attempt has been made."""
  PENDING

  """
  The payment attempt has been authorized, but the payment has been refunded. This is a final state.
  """
  REFUNDED

  """
  The payment attempt has been authorized, but the payment has been reserved, but not captured.
  """
  RESERVED
}

type OrderResponse {
  order: Order!
}

input OrdersInput {
  """Only get orders for the given product ID."""
  productId: ID

  """
  Only get orders for the given user ID. Requires super user status,
  or the user ID to match the user ID of the order. Omit to default to
  the current user.
  """
  userId: ID
}

type OrdersResponse {
  orders: [Order!]!
  total: Int!
}

type Organization {
  description: String!
  events: [Event!]!

  """
  The features that are enabled for the organization.
  Changing these fields requires super user permissions.
  """
  featurePermissions: [FeaturePermission!]!
  id: ID!
  listings: [Listing!]!

  """The members of the organization"""
  members: [Member!]!
  name: String!
}

input OrganizationInput {
  id: ID!
}

type OrganizationReseponse {
  organization: Organization!
}

type OrganizationsResponse {
  organizations: [Organization!]!
}

enum ParticipationStatus {
  """The user is confirmed to be attending the event"""
  CONFIRMED

  """The user is on the wait list for the event"""
  ON_WAITLIST

  """
  The user has signed up for the event, and had their sign up removed by an admin
  """
  REMOVED

  """The user has signed up for the event, and then retracted their sign up"""
  RETRACTED
}

type PaymentAttempt {
  id: ID!
  isFinalState: Boolean!

  """The order that the payment attempt is for."""
  order: Order!

  """The reference for the payment attempt with the payment provider."""
  reference: String!

  """
  The current state of the payment attempt. If the payment attempt is CREATED, it is recommended to poll
  to get the most current state, as it can change asynchronously.
  """
  state: PaymentAttemptState!
}

enum PaymentAttemptState {
  """The payment attempt was aborted by the user. This is a final state."""
  ABORTED

  """
  The payment attempt was successful, and the user has authorized the payment. This is a final state.
  """
  AUTHORIZED

  """The payment attempt has been started, but not completed."""
  CREATED

  """The payment attempt expired. This is a final state."""
  EXPIRED

  """The payment attempt failed. This is a final state."""
  FAILED

  """
  The payment attempt was terminated (typically by us). This is a final state.
  """
  TERMINATED
}

input PaymentAttemptsInput {
  """Only get payment atttempts for the given order ID."""
  orderId: ID

  """Only get payment attempts for the given product ID."""
  productId: ID

  """
  Only get payment attempts for the given user ID. Requires super user status,
  or the user ID to match the user ID of the payment attempt. Omit to default to
  the current user.
  """
  userId: ID
}

type PaymentAttemptsResponse {
  paymentAttempts: [PaymentAttempt!]!
  total: Int!
}

type Price {
  """The unit of the price, e.g. NOK, USD, EUR, etc."""
  unit: String!

  """The value of the price, in the given unit."""
  value: Int!
  valueInNok: Float!
}

"""
PrivateUser should only be used when accessed by the authenticated user themselves
as it contains sensitive information.
"""
type PrivateUser {
  allergies: String

  """If the user is permitted to update their graduation year"""
  canUpdateYear: Boolean!
  createdAt: DateTime!

  """Student email"""
  email: String!
  firstLogin: Boolean!
  firstName: String!

  """The users grade year, from 1 - 6(+)"""
  gradeYear: Int

  """Expected graduation year for the user"""
  graduationYear: Int

  """The last time the users graduation year was updated"""
  graduationYearUpdatedAt: DateTime
  id: ID!

  """true if the user is a super user, false otherwise"""
  isSuperUser: Boolean!
  lastName: String!

  """All organizations the user is a member of"""
  organizations: [Organization!]!
  phoneNumber: String

  """The users' study program"""
  studyProgram: StudyProgram
  username: String!
}

type Product {
  """The description of the product."""
  description: String!
  id: ID!

  """The name of the product"""
  name: String!

  """price in øre, i.e. 100 = 1 NOK"""
  price: Price!
}

type ProductResponse {
  products: [Product!]!
  total: Int!
}

"""
The public facing user type, with limited information.
This type is is available to other users, and should therefore not contain sensitive information,
unless the information is restricted by access control.
"""
type PublicUser {
  """The users' given/first name"""
  firstName: String!

  """The users' grade year"""
  gradeYear: Int
  id: ID!

  """The users' family/last name"""
  lastName: String!

  """The users' username"""
  username: String!
}

type Query {
  bookingContact: BookingContactResponse!
  bookingSemesters: BookingSemestersResponse!
  cabins: CabinsResponse!
  categories: EventCategoriesResponse!
  event(data: EventInput!): EventResponse!
  events(data: EventsInput): EventsResponse!
  hasFeaturePermission(data: HasFeaturePermissionInput!): HasFeaturePermissionResponse!
  hasRole(data: HasRoleInput!): HasRoleResponse!
  listing(data: ListingInput!): ListingResponse!
  listings: ListingsResponse!

  """Get an order by its ID."""
  order(data: OrderInput!): OrderResponse!

  """
  Get orders, filtered by the given input. Unless the user is a super user, only
  orders for the current user will be returned.
  """
  orders(data: OrdersInput): OrdersResponse!

  """Get an organization by its ID"""
  organization(data: OrganizationInput!): OrganizationReseponse!

  """Get all organizations"""
  organizations: OrganizationsResponse!

  """
  Get payment attempts, filtered by the given input. Unless the user is a super user, only
  payment attempts for the current user will be returned.
  """
  paymentAttempts(data: PaymentAttemptsInput): PaymentAttemptsResponse!
  products: ProductResponse!
  serverTime: ServerTimeResponse!
  user: UserResponse!
  users: UsersResponse!
}

input RemoveMemberInput {
  id: ID!
}

type RemoveMemberResponse {
  member: Member!
}

input RetractSignUpInput {
  """The event to retract the sign up for"""
  eventId: ID!
}

type RetractSignUpResponse {
  signUp: SignUp!
}

enum Role {
  """
  An admin of the organization, can do everything a member can,
  # and can also manage members in the organization and delete the organization.
  """
  ADMIN

  """
  A member of the organization, can do everything except
  manage members in the organization and delete the organization.
  """
  MEMBER
}

enum Semester {
  FALL
  SPRING
}

type ServerTimeResponse {
  serverTime: DateTime!
}

type SignUp {
  """The event the user signed up for"""
  event: Event!
  id: ID!
  order: Order

  """The status of the user's participation in the event"""
  participationStatus: ParticipationStatus!

  """The user that signed up for the event"""
  user: PublicUser!
  userProvidedInformation: String
}

enum SignUpAvailability {
  """
  Sign ups are open, enabled, and there is at least one slot available for the user to sign up for.
  """
  AVAILABLE

  """The user is not signed up for the event, and sign ups are closed"""
  CLOSED
  CONFIRMED

  """Sign ups are not enabled for the event"""
  DISABLED

  """Sign ups have not opened yet"""
  NOT_OPEN
  ON_WAITLIST

  """
  There are no slots for the event for the user to sign up for, regardless of their current capacity.
  If the user is not logged in, the status will always be UNAVAILABLE.
  """
  UNAVAILABLE

  """
  All slots are full, and the user is not signed up for the event. The user can sign up for the wait list.
  """
  WAITLIST_AVAILABLE
}

input SignUpData {
  """
  Total capacity for the event, regardless of the capacity in each slot.
  This number takes precedence over the capacity in each slot, so if the remaining capacity on the event is 0
  no more users can be registered as attending.
  """
  capacity: Int!

  """
  The time that sign ups close for the event. This must be after signUpsOpenAt.
  """
  signUpsEndAt: DateTime!

  """
  The time that sign ups open for the event. This must be before the start time of the event.
  """
  signUpsStartAt: DateTime!

  """
  The slots for the event. If this is not provided, but capacity is, then all users can attend the event.
  """
  slots: [CreateEventSlot!]!

  """
  Ticket purchase details for the event. If this is not provided, then the event is free.
  """
  tickets: EventTicketData
}

input SignUpInput {
  """The event to sign up for"""
  eventId: ID!

  """
  If the event requires user provided information, this field must be set
  """
  userProvidedInformation: String
}

type SignUpResponse {
  signUp: SignUp!
}

type SignUps {
  confirmed: SignUpsWithTotalCount!
  retracted: SignUpsWithTotalCount!
  waitList: SignUpsWithTotalCount!
}

type SignUpsWithTotalCount {
  signUps: [SignUp!]!
  total: Int!
}

enum Status {
  CANCELLED
  CONFIRMED
  PENDING
  REJECTED
}

type StudyProgram {
  externalId: String!
  id: ID!
  name: String!
}

input SuperUpdateUserInput {
  allergies: String
  firstName: String
  graduationYear: Int
  isSuperUser: Boolean
  lastName: String
  phoneNumber: String
}

type SuperUpdateUserResponse {
  user: PrivateUser!
}

input UpdateBookingContactInput {
  """
  The email address of the booking contact, will be publicly available, pass the empty string to remove the email address
  """
  email: String

  """
  The full name of the booking contact, will be publicly available, pass the empty string to remove the name
  """
  name: String

  """
  The phone number of the booking contact, will be publicly available, pass the empty string to remove the phone number
  """
  phoneNumber: String
}

type UpdateBookingContactResponse {
  bookingContact: BookingContact!
}

type UpdateBookingResponse {
  booking: Booking!
}

input UpdateBookingSemesterInput {
  """Whether or not bookings are enabled for this semester"""
  bookingsEnabled: Boolean

  """The end date for the booking period"""
  endAt: DateTime

  """
  There are only ever two semesters, so this is the ID of the semester to update.
  """
  semester: Semester!

  """The start date for the booking period"""
  startAt: DateTime
}

type UpdateBookingSemesterResponse {
  bookingSemester: BookingSemester!
}

input UpdateBookingStatusInput {
  id: ID!
  status: Status!
}

input UpdateCategoriesInput {
  id: ID!
}

input UpdateEventCategoryInput {
  id: ID!
  name: String!
}

type UpdateEventCategoryResponse {
  category: EventCategory!
}

input UpdateEventInput {
  """
  Total capacity for the event, regardless of the capacity in each slot.
  This number takes precedence over the capacity in each slot, so if the remaining capacity on the event is 0
  no more users can be registered as attending. Cannot be less than the number of users currently signed up for the event.
  """
  capacity: Int

  """categories is a list of cateogry IDs to which the event belongs"""
  categories: [UpdateCategoriesInput!]

  """
  The description of the event, defaults to "". We support markdown on the client, so this can be markdown.
  This will be displayed to users.
  """
  description: String

  """The end time of the event, must be after startAt."""
  endAt: DateTime

  """location of the event"""
  location: String

  """The name of the event, this will be displayed to users"""
  name: String

  """If true, sign ups require user provided information"""
  signUpsRequireUserProvidedInformation: Boolean

  """If true, sign ups are retractable for the event"""
  signUpsRetractable: Boolean
  slots: UpdateSlotsInput

  """
  The start time of the event. Must be before endAt and after the current time.
  """
  startAt: DateTime
}

type UpdateEventResponse {
  event: Event!
}

input UpdateListingInput {
  """An optional URL to the application form for the listing."""
  applicationUrl: String

  """
  At what time the listing will close, will show as a deadline to users, and the listing will be hidden afterwards
  """
  closesAt: DateTime

  """The description of the listing, can be markdown."""
  description: String

  """The name of the listing, will be visible to users."""
  name: String
}

type UpdateListingResponse {
  listing: Listing!
}

input UpdateOrganizationInput {
  """
  The new description of the organization, cannot exceed 10 000 characters
  Omitting the value or passing null will leave the description unchanged
  """
  description: String

  """
  Features to enable for the organization.
  Requires that the current user is a super user, otherwise, this field is ignored.
  """
  featurePermissions: [FeaturePermission!]

  """The ID of the organization to update"""
  id: ID!

  """
  The new name of the organization
  Omitting the value or passing null will leave the name unchanged
  """
  name: String
}

type UpdateOrganizationResponse {
  organization: Organization!
}

input UpdateSlotInput {
  capacity: Int
  gradeYears: [Int!]
  id: ID!
}

input UpdateSlotsInput {
  create: [CreateSlotInput!]
  delete: [DeleteSlotInput!]
  update: [UpdateSlotInput!]
}

input UpdateUserInput {
  allergies: String
  firstName: String
  graduationYear: Int
  lastName: String
  phoneNumber: String
}

type UpdateUserResponse {
  user: PrivateUser!
}

type UserResponse {
  user: PrivateUser
}

type UsersResponse {
  super: [PrivateUser!]!
  total: Int!
  users: [PublicUser!]!
}